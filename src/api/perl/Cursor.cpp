/*
 * This file was generated automatically by ExtUtils::ParseXS version 3.18 from the
 * contents of Cursor.xs. Do not edit this file, edit Cursor.xs instead.
 *
 *    ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "Cursor.xs"
/* Copyright (c) 1999-2018 David Muse
   See the file COPYING for more information */

#include <config.h>

// SCO OSR6 requires this
#ifdef SQLRELAY_HAVE_SYS_VNODE_H
	#include <sys/vnode.h>
#endif

#include "../c++/sqlrelay/sqlrclient.h"
#include <EXTERN.h>
#define explicit

#if defined(WIN32)

	// some versions of active perl erroneously try to
	// use __inline__ which isn't valid for MSVC
	#ifdef _MSC_VER
		#define __inline__ __inline
	#endif

	// msvc < 2013 (version 18.00) don't have stdbool.h
	// active perl 5.20 and up require either stdbool.h or this workaround
	#if _MSC_VER<1800
		#include <patchlevel.h>
		#if PERL_REVISION>5 || (PERL_REVISION==5 && PERL_VERSION>=20)
			#define PERL_BOOL_AS_CHAR
			#define __inline__ inline
		#endif
	#endif
#endif

#ifndef _SCO_DS
extern "C" {
#endif
	#include <perl.h>
#ifndef _SCO_DS
}
#endif

#include <XSUB.h>
#ifdef CLASS
	#undef CLASS
#endif

#ifdef THIS
	#undef THIS
#endif

#ifdef PERL500
        #ifndef SvUV
                #define SvUV SvIV
        #endif
        #ifndef sv_setuv
                #define sv_setuv sv_setiv
        #endif
	#ifndef PERLREALLYOLD
        	#undef sv_setpv
        	#define sv_setpv(a,b) Perl_sv_setpv(a,(char *)b)
        	#undef sv_setpvn
        	#define sv_setpvn(a,b,c) Perl_sv_setpvn(a,(char *)b,c)
	#else
		#define CLASS "SQLRelay::Cursor"
        #endif
#endif

#ifdef WIN32
	#undef XS_EXTERNAL
	#undef XS_INTERNAL
	#define XS_EXTERNAL(name) __declspec(dllexport) XSPROTO(name)
	#define XS_INTERNAL(name) STATIC XSPROTO(name)
#endif

#ifndef PERLREALLYOLD
	#ifndef na
		#define na PL_na
	#endif

	#ifndef sv_undef
		#define sv_undef PL_sv_undef
	#endif
#endif

/* xsubpp outputs __attribute__((noreturn)) this isn't
 * understood by gcc < 3.0. */
#ifdef __GNUC__
	#if __GNUC__ < 3
		#define __attribute__(x)
	#endif
#endif

#ifdef WIN32
	#undef XS_EXTERNAL
	#undef XS_INTERNAL
	#define XS_EXTERNAL(name) __declspec(dllexport) XSPROTO(name)
	#define XS_INTERNAL(name) STATIC XSPROTO(name)
#endif

typedef class sqlrcursor sqlrcursor;

#line 112 "Cursor.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef dVAR
#  define dVAR		dNOOP
#endif


/* This stuff is not part of the API! You have been warned. */
#ifndef PERL_VERSION_DECIMAL
#  define PERL_VERSION_DECIMAL(r,v,s) (r*1000000 + v*1000 + s)
#endif
#ifndef PERL_DECIMAL_VERSION
#  define PERL_DECIMAL_VERSION \
	  PERL_VERSION_DECIMAL(PERL_REVISION,PERL_VERSION,PERL_SUBVERSION)
#endif
#ifndef PERL_VERSION_GE
#  define PERL_VERSION_GE(r,v,s) \
	  (PERL_DECIMAL_VERSION >= PERL_VERSION_DECIMAL(r,v,s))
#endif
#ifndef PERL_VERSION_LE
#  define PERL_VERSION_LE(r,v,s) \
	  (PERL_DECIMAL_VERSION <= PERL_VERSION_DECIMAL(r,v,s))
#endif

/* XS_INTERNAL is the explicit static-linkage variant of the default
 * XS macro.
 *
 * XS_EXTERNAL is the same as XS_INTERNAL except it does not include
 * "STATIC", ie. it exports XSUB symbols. You probably don't want that
 * for anything but the BOOT XSUB.
 *
 * See XSUB.h in core!
 */


/* TODO: This might be compatible further back than 5.10.0. */
#if PERL_VERSION_GE(5, 10, 0) && PERL_VERSION_LE(5, 15, 1)
#  undef XS_EXTERNAL
#  undef XS_INTERNAL
#  if defined(__CYGWIN__) && defined(USE_DYNAMIC_LOADING)
#    define XS_EXTERNAL(name) __declspec(dllexport) XSPROTO(name)
#    define XS_INTERNAL(name) STATIC XSPROTO(name)
#  endif
#  if defined(__SYMBIAN32__)
#    define XS_EXTERNAL(name) EXPORT_C XSPROTO(name)
#    define XS_INTERNAL(name) EXPORT_C STATIC XSPROTO(name)
#  endif
#  ifndef XS_EXTERNAL
#    if defined(HASATTRIBUTE_UNUSED) && !defined(__cplusplus)
#      define XS_EXTERNAL(name) void name(pTHX_ CV* cv __attribute__unused__)
#      define XS_INTERNAL(name) STATIC void name(pTHX_ CV* cv __attribute__unused__)
#    else
#      ifdef __cplusplus
#        define XS_EXTERNAL(name) extern "C" XSPROTO(name)
#        define XS_INTERNAL(name) static XSPROTO(name)
#      else
#        define XS_EXTERNAL(name) XSPROTO(name)
#        define XS_INTERNAL(name) STATIC XSPROTO(name)
#      endif
#    endif
#  endif
#endif

/* perl >= 5.10.0 && perl <= 5.15.1 */


/* The XS_EXTERNAL macro is used for functions that must not be static
 * like the boot XSUB of a module. If perl didn't have an XS_EXTERNAL
 * macro defined, the best we can do is assume XS is the same.
 * Dito for XS_INTERNAL.
 */
#ifndef XS_EXTERNAL
#  define XS_EXTERNAL(name) XS(name)
#endif
#ifndef XS_INTERNAL
#  define XS_INTERNAL(name) XS(name)
#endif

/* Now, finally, after all this mess, we want an ExtUtils::ParseXS
 * internal macro that we're free to redefine for varying linkage due
 * to the EXPORT_XSUB_SYMBOLS XS keyword. This is internal, use
 * XS_EXTERNAL(name) or XS_INTERNAL(name) in your code if you need to!
 */

#undef XS_EUPXS
#if defined(PERL_EUPXS_ALWAYS_EXPORT)
#  define XS_EUPXS(name) XS_EXTERNAL(name)
#else
   /* default to internal */
#  define XS_EUPXS(name) XS_INTERNAL(name)
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
            Perl_croak(aTHX_ "Usage: %s::%s(%s)", hvname, gvname, params);
        else
            Perl_croak(aTHX_ "Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
        Perl_croak(aTHX_ "Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#ifdef PERL_IMPLICIT_CONTEXT
#define croak_xs_usage(a,b)    S_croak_xs_usage(aTHX_ a,b)
#else
#define croak_xs_usage        S_croak_xs_usage
#endif

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#line 254 "Cursor.c"

XS_EUPXS(XS_SQLRelay__Cursor_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_SQLRelay__Cursor_new)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "CLASS, sqlrc");
    {
	sqlrconnection *	sqlrc;
	char *	CLASS = (char *)SvPV_nolen(ST(0))
;
	sqlrcursor *	RETVAL;

	if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) )
		sqlrc = (sqlrconnection *)SvIV((SV*)SvRV( ST(1) ));
	else{
		warn( "SQLRelay::Cursor::new() -- sqlrc is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 108 "Cursor.xs"
		RETVAL=new sqlrcursor(sqlrc,true);
#line 277 "Cursor.c"
	ST(0) = sv_newmortal();
	sv_setref_pv( ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_SQLRelay__Cursor_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_SQLRelay__Cursor_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	sqlrcursor *	THIS;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (sqlrcursor *)SvIV((SV*)SvRV( ST(0) ));
	else{
		warn( "SQLRelay::Cursor::DESTROY() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	delete THIS;
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_SQLRelay__Cursor_setResultSetBufferSize); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_SQLRelay__Cursor_setResultSetBufferSize)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, rows");
    {
	uint64_t	rows;
	sqlrcursor *	THIS;

	rows=(uint64_t)SvUV(ST(1))
;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (sqlrcursor *)SvIV((SV*)SvRV( ST(0) ));
	else{
		warn( "SQLRelay::Cursor::setResultSetBufferSize() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	THIS->setResultSetBufferSize(rows);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_SQLRelay__Cursor_getResultSetBufferSize); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_SQLRelay__Cursor_getResultSetBufferSize)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	sqlrcursor *	THIS;
	uint64_t	RETVAL;
	dXSTARG;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (sqlrcursor *)SvIV((SV*)SvRV( ST(0) ));
	else{
		warn( "SQLRelay::Cursor::getResultSetBufferSize() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	RETVAL = THIS->getResultSetBufferSize();
	XSprePUSH; PUSHu((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_SQLRelay__Cursor_dontGetColumnInfo); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_SQLRelay__Cursor_dontGetColumnInfo)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	sqlrcursor *	THIS;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (sqlrcursor *)SvIV((SV*)SvRV( ST(0) ));
	else{
		warn( "SQLRelay::Cursor::dontGetColumnInfo() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	THIS->dontGetColumnInfo();
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_SQLRelay__Cursor_getColumnInfo); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_SQLRelay__Cursor_getColumnInfo)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	sqlrcursor *	THIS;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (sqlrcursor *)SvIV((SV*)SvRV( ST(0) ));
	else{
		warn( "SQLRelay::Cursor::getColumnInfo() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	THIS->getColumnInfo();
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_SQLRelay__Cursor_mixedCaseColumnNames); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_SQLRelay__Cursor_mixedCaseColumnNames)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	sqlrcursor *	THIS;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (sqlrcursor *)SvIV((SV*)SvRV( ST(0) ));
	else{
		warn( "SQLRelay::Cursor::mixedCaseColumnNames() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	THIS->mixedCaseColumnNames();
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_SQLRelay__Cursor_upperCaseColumnNames); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_SQLRelay__Cursor_upperCaseColumnNames)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	sqlrcursor *	THIS;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (sqlrcursor *)SvIV((SV*)SvRV( ST(0) ));
	else{
		warn( "SQLRelay::Cursor::upperCaseColumnNames() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	THIS->upperCaseColumnNames();
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_SQLRelay__Cursor_lowerCaseColumnNames); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_SQLRelay__Cursor_lowerCaseColumnNames)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	sqlrcursor *	THIS;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (sqlrcursor *)SvIV((SV*)SvRV( ST(0) ));
	else{
		warn( "SQLRelay::Cursor::lowerCaseColumnNames() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	THIS->lowerCaseColumnNames();
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_SQLRelay__Cursor_cacheToFile); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_SQLRelay__Cursor_cacheToFile)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, filename");
    {
	const char *	filename = (const char *)SvPV_nolen(ST(1))
;
	sqlrcursor *	THIS;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (sqlrcursor *)SvIV((SV*)SvRV( ST(0) ));
	else{
		warn( "SQLRelay::Cursor::cacheToFile() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	THIS->cacheToFile(filename);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_SQLRelay__Cursor_setCacheTtl); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_SQLRelay__Cursor_setCacheTtl)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, ttl");
    {
	uint32_t	ttl;
	sqlrcursor *	THIS;

	ttl=(uint32_t)SvUV(ST(1))
;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (sqlrcursor *)SvIV((SV*)SvRV( ST(0) ));
	else{
		warn( "SQLRelay::Cursor::setCacheTtl() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	THIS->setCacheTtl(ttl);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_SQLRelay__Cursor_getCacheFileName); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_SQLRelay__Cursor_getCacheFileName)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	sqlrcursor *	THIS;
	const char *	RETVAL;
	dXSTARG;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (sqlrcursor *)SvIV((SV*)SvRV( ST(0) ));
	else{
		warn( "SQLRelay::Cursor::getCacheFileName() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	RETVAL = THIS->getCacheFileName();
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_SQLRelay__Cursor_cacheOff); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_SQLRelay__Cursor_cacheOff)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	sqlrcursor *	THIS;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (sqlrcursor *)SvIV((SV*)SvRV( ST(0) ));
	else{
		warn( "SQLRelay::Cursor::cacheOff() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	THIS->cacheOff();
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_SQLRelay__Cursor_getDatabaseList); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_SQLRelay__Cursor_getDatabaseList)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, wild");
    {
	const char *	wild = (const char *)SvPV_nolen(ST(1))
;
	sqlrcursor *	THIS;
	bool	RETVAL;
	dXSTARG;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (sqlrcursor *)SvIV((SV*)SvRV( ST(0) ));
	else{
		warn( "SQLRelay::Cursor::getDatabaseList() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	RETVAL = THIS->getDatabaseList(wild);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_SQLRelay__Cursor_getTableList); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_SQLRelay__Cursor_getTableList)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, wild");
    {
	const char *	wild = (const char *)SvPV_nolen(ST(1))
;
	sqlrcursor *	THIS;
	bool	RETVAL;
	dXSTARG;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (sqlrcursor *)SvIV((SV*)SvRV( ST(0) ));
	else{
		warn( "SQLRelay::Cursor::getTableList() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	RETVAL = THIS->getTableList(wild);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_SQLRelay__Cursor_getColumnList); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_SQLRelay__Cursor_getColumnList)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, table, wild");
    {
	const char *	table = (const char *)SvPV_nolen(ST(1))
;
	const char *	wild = (const char *)SvPV_nolen(ST(2))
;
	sqlrcursor *	THIS;
	bool	RETVAL;
	dXSTARG;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (sqlrcursor *)SvIV((SV*)SvRV( ST(0) ));
	else{
		warn( "SQLRelay::Cursor::getColumnList() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	RETVAL = THIS->getColumnList(table, wild);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_SQLRelay__Cursor_sendQuery); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_SQLRelay__Cursor_sendQuery)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, query");
    {
	const char *	query = (const char *)SvPV_nolen(ST(1))
;
	sqlrcursor *	THIS;
	bool	RETVAL;
	dXSTARG;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (sqlrcursor *)SvIV((SV*)SvRV( ST(0) ));
	else{
		warn( "SQLRelay::Cursor::sendQuery() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	RETVAL = THIS->sendQuery(query);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_SQLRelay__Cursor_sendQueryWithLength); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_SQLRelay__Cursor_sendQueryWithLength)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, query, length");
    {
	const char *	query = (const char *)SvPV_nolen(ST(1))
;
	uint32_t	length;
	sqlrcursor *	THIS;
	bool	RETVAL;
	dXSTARG;

	length=(uint32_t)SvUV(ST(2))
;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (sqlrcursor *)SvIV((SV*)SvRV( ST(0) ));
	else{
		warn( "SQLRelay::Cursor::sendQueryWithLength() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 173 "Cursor.xs"
		RETVAL=THIS->sendQuery(query,length);
#line 717 "Cursor.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_SQLRelay__Cursor_sendFileQuery); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_SQLRelay__Cursor_sendFileQuery)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, path, file");
    {
	const char *	path = (const char *)SvPV_nolen(ST(1))
;
	const char *	file = (const char *)SvPV_nolen(ST(2))
;
	sqlrcursor *	THIS;
	bool	RETVAL;
	dXSTARG;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (sqlrcursor *)SvIV((SV*)SvRV( ST(0) ));
	else{
		warn( "SQLRelay::Cursor::sendFileQuery() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	RETVAL = THIS->sendFileQuery(path, file);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_SQLRelay__Cursor_prepareQuery); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_SQLRelay__Cursor_prepareQuery)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, query");
    {
	const char *	query = (const char *)SvPV_nolen(ST(1))
;
	sqlrcursor *	THIS;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (sqlrcursor *)SvIV((SV*)SvRV( ST(0) ));
	else{
		warn( "SQLRelay::Cursor::prepareQuery() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	THIS->prepareQuery(query);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_SQLRelay__Cursor_prepareQueryWithLength); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_SQLRelay__Cursor_prepareQueryWithLength)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, query, length");
    {
	const char *	query = (const char *)SvPV_nolen(ST(1))
;
	uint32_t	length;
	sqlrcursor *	THIS;

	length=(uint32_t)SvUV(ST(2))
;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (sqlrcursor *)SvIV((SV*)SvRV( ST(0) ));
	else{
		warn( "SQLRelay::Cursor::prepareQueryWithLength() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 191 "Cursor.xs"
		THIS->prepareQuery(query,length);
#line 803 "Cursor.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_SQLRelay__Cursor_prepareFileQuery); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_SQLRelay__Cursor_prepareFileQuery)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, path, file");
    {
	const char *	path = (const char *)SvPV_nolen(ST(1))
;
	const char *	file = (const char *)SvPV_nolen(ST(2))
;
	sqlrcursor *	THIS;
	bool	RETVAL;
	dXSTARG;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (sqlrcursor *)SvIV((SV*)SvRV( ST(0) ));
	else{
		warn( "SQLRelay::Cursor::prepareFileQuery() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	RETVAL = THIS->prepareFileQuery(path, file);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_SQLRelay__Cursor_substitution); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_SQLRelay__Cursor_substitution)
{
    dVAR; dXSARGS;
    if (items < 2)
       croak_xs_usage(cv,  "THIS, variable, ...");
    {
	const char *	variable = (const char *)SvPV_nolen(ST(1))
;
	sqlrcursor *	THIS;
	bool	RETVAL;
	dXSTARG;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (sqlrcursor *)SvIV((SV*)SvRV( ST(0) ));
	else{
		warn( "SQLRelay::Cursor::substitution() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 203 "Cursor.xs"
		RETVAL=1;
		if (SvIOK(ST(2))) {
			THIS->substitution(variable,(int64_t)SvIV(ST(2)));
		} else if (SvNOK(ST(2))) {
			THIS->substitution(variable,(double)SvNV(ST(2)),
						(uint32_t)SvIV(ST(3)),
						(uint32_t)SvIV(ST(4)));
		} else if (SvPOK(ST(2))) {
			THIS->substitution(variable,SvPV(ST(2),na));
		} else if (!SvOK(ST(2))) {
			THIS->substitution(variable,(const char *)NULL);
		} else {
			RETVAL=0;
		}
#line 874 "Cursor.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_SQLRelay__Cursor_clearBinds); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_SQLRelay__Cursor_clearBinds)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	sqlrcursor *	THIS;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (sqlrcursor *)SvIV((SV*)SvRV( ST(0) ));
	else{
		warn( "SQLRelay::Cursor::clearBinds() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	THIS->clearBinds();
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_SQLRelay__Cursor_countBindVariables); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_SQLRelay__Cursor_countBindVariables)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	sqlrcursor *	THIS;
	uint16_t	RETVAL;
	dXSTARG;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (sqlrcursor *)SvIV((SV*)SvRV( ST(0) ));
	else{
		warn( "SQLRelay::Cursor::countBindVariables() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	RETVAL = THIS->countBindVariables();
	XSprePUSH; PUSHu((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_SQLRelay__Cursor_inputBind); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_SQLRelay__Cursor_inputBind)
{
    dVAR; dXSARGS;
    if (items < 2)
       croak_xs_usage(cv,  "THIS, variable, ...");
    {
	const char *	variable = (const char *)SvPV_nolen(ST(1))
;
	sqlrcursor *	THIS;
	bool	RETVAL;
	dXSTARG;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (sqlrcursor *)SvIV((SV*)SvRV( ST(0) ));
	else{
		warn( "SQLRelay::Cursor::inputBind() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 230 "Cursor.xs"
		RETVAL=1;
		if (SvIOK(ST(2))) {
			THIS->inputBind(variable,(int64_t)SvIV(ST(2)));
		} else if (SvNOK(ST(2))) {
			THIS->inputBind(variable,(double)SvNV(ST(2)),
						(uint32_t)SvIV(ST(3)),
						(uint32_t)SvIV(ST(4)));
		} else if (SvPOK(ST(2))) {
			if (SvIOK(ST(3)) && SvIV(ST(3))>0) {
				THIS->inputBind(variable,SvPV(ST(2),na),
							(uint32_t)SvIV(ST(3)));
			} else {
				THIS->inputBind(variable,SvPV(ST(2),na));
			}
		} else if (!SvOK(ST(2))) {
			THIS->inputBind(variable,(const char *)NULL);
		} else {
			RETVAL=0;
		}
#line 970 "Cursor.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_SQLRelay__Cursor_inputBindBlob); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_SQLRelay__Cursor_inputBindBlob)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "THIS, variable, value, size");
    {
	const char *	variable = (const char *)SvPV_nolen(ST(1))
;
	const char *	value = (const char *)SvPV_nolen(ST(2))
;
	uint32_t	size;
	sqlrcursor *	THIS;
	bool	RETVAL;
	dXSTARG;

	size=(uint32_t)SvUV(ST(3))
;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (sqlrcursor *)SvIV((SV*)SvRV( ST(0) ));
	else{
		warn( "SQLRelay::Cursor::inputBindBlob() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 258 "Cursor.xs"
		RETVAL=0;
		if (SvPOK(ST(2))) {
			THIS->inputBindBlob(variable,value,size);
			RETVAL=1;
		} else if (!SvOK(ST(2))) {
			THIS->inputBindBlob(variable,NULL,0);
		}
#line 1011 "Cursor.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_SQLRelay__Cursor_inputBindClob); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_SQLRelay__Cursor_inputBindClob)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "THIS, variable, value, size");
    {
	const char *	variable = (const char *)SvPV_nolen(ST(1))
;
	const char *	value = (const char *)SvPV_nolen(ST(2))
;
	uint32_t	size;
	sqlrcursor *	THIS;
	bool	RETVAL;
	dXSTARG;

	size=(uint32_t)SvUV(ST(3))
;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (sqlrcursor *)SvIV((SV*)SvRV( ST(0) ));
	else{
		warn( "SQLRelay::Cursor::inputBindClob() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 274 "Cursor.xs"
		RETVAL=0;
		if (SvPOK(ST(2))) {
			THIS->inputBindClob(variable,value,size);
			RETVAL=1;
		} else if (!SvOK(ST(2))) {
			THIS->inputBindClob(variable,NULL,0);
		}
#line 1052 "Cursor.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_SQLRelay__Cursor_validateBinds); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_SQLRelay__Cursor_validateBinds)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	sqlrcursor *	THIS;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (sqlrcursor *)SvIV((SV*)SvRV( ST(0) ));
	else{
		warn( "SQLRelay::Cursor::validateBinds() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	THIS->validateBinds();
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_SQLRelay__Cursor_validBind); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_SQLRelay__Cursor_validBind)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, variable");
    {
	const char *	variable = (const char *)SvPV_nolen(ST(1))
;
	sqlrcursor *	THIS;
	bool	RETVAL;
	dXSTARG;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (sqlrcursor *)SvIV((SV*)SvRV( ST(0) ));
	else{
		warn( "SQLRelay::Cursor::validBind() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	RETVAL = THIS->validBind(variable);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_SQLRelay__Cursor_executeQuery); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_SQLRelay__Cursor_executeQuery)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	sqlrcursor *	THIS;
	bool	RETVAL;
	dXSTARG;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (sqlrcursor *)SvIV((SV*)SvRV( ST(0) ));
	else{
		warn( "SQLRelay::Cursor::executeQuery() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	RETVAL = THIS->executeQuery();
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_SQLRelay__Cursor_fetchFromBindCursor); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_SQLRelay__Cursor_fetchFromBindCursor)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	sqlrcursor *	THIS;
	bool	RETVAL;
	dXSTARG;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (sqlrcursor *)SvIV((SV*)SvRV( ST(0) ));
	else{
		warn( "SQLRelay::Cursor::fetchFromBindCursor() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	RETVAL = THIS->fetchFromBindCursor();
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_SQLRelay__Cursor_defineOutputBindString); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_SQLRelay__Cursor_defineOutputBindString)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, variable, length");
    {
	const char *	variable = (const char *)SvPV_nolen(ST(1))
;
	uint32_t	length;
	sqlrcursor *	THIS;

	length=(uint32_t)SvUV(ST(2))
;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (sqlrcursor *)SvIV((SV*)SvRV( ST(0) ));
	else{
		warn( "SQLRelay::Cursor::defineOutputBindString() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	THIS->defineOutputBindString(variable, length);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_SQLRelay__Cursor_defineOutputBindInteger); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_SQLRelay__Cursor_defineOutputBindInteger)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, variable");
    {
	const char *	variable = (const char *)SvPV_nolen(ST(1))
;
	sqlrcursor *	THIS;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (sqlrcursor *)SvIV((SV*)SvRV( ST(0) ));
	else{
		warn( "SQLRelay::Cursor::defineOutputBindInteger() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	THIS->defineOutputBindInteger(variable);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_SQLRelay__Cursor_defineOutputBindDouble); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_SQLRelay__Cursor_defineOutputBindDouble)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, variable");
    {
	const char *	variable = (const char *)SvPV_nolen(ST(1))
;
	sqlrcursor *	THIS;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (sqlrcursor *)SvIV((SV*)SvRV( ST(0) ));
	else{
		warn( "SQLRelay::Cursor::defineOutputBindDouble() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	THIS->defineOutputBindDouble(variable);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_SQLRelay__Cursor_defineOutputBindBlob); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_SQLRelay__Cursor_defineOutputBindBlob)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, variable");
    {
	const char *	variable = (const char *)SvPV_nolen(ST(1))
;
	sqlrcursor *	THIS;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (sqlrcursor *)SvIV((SV*)SvRV( ST(0) ));
	else{
		warn( "SQLRelay::Cursor::defineOutputBindBlob() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	THIS->defineOutputBindBlob(variable);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_SQLRelay__Cursor_defineOutputBindClob); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_SQLRelay__Cursor_defineOutputBindClob)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, variable");
    {
	const char *	variable = (const char *)SvPV_nolen(ST(1))
;
	sqlrcursor *	THIS;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (sqlrcursor *)SvIV((SV*)SvRV( ST(0) ));
	else{
		warn( "SQLRelay::Cursor::defineOutputBindClob() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	THIS->defineOutputBindClob(variable);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_SQLRelay__Cursor_defineOutputBindCursor); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_SQLRelay__Cursor_defineOutputBindCursor)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, variable");
    {
	const char *	variable = (const char *)SvPV_nolen(ST(1))
;
	sqlrcursor *	THIS;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (sqlrcursor *)SvIV((SV*)SvRV( ST(0) ));
	else{
		warn( "SQLRelay::Cursor::defineOutputBindCursor() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	THIS->defineOutputBindCursor(variable);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_SQLRelay__Cursor_getOutputBindString); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_SQLRelay__Cursor_getOutputBindString)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, variable");
    {
	const char *	variable = (const char *)SvPV_nolen(ST(1))
;
	sqlrcursor *	THIS;
	const char *	RETVAL;
	dXSTARG;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (sqlrcursor *)SvIV((SV*)SvRV( ST(0) ));
	else{
		warn( "SQLRelay::Cursor::getOutputBindString() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 326 "Cursor.xs"
		const char	*value=THIS->getOutputBindString(variable);
		uint32_t	length=THIS->getOutputBindLength(variable);
		ST(0)=sv_newmortal();
		if (value) {
			sv_setpvn(ST(0),value,length);
		} else {
			ST(0)=&sv_undef;
		}
#line 1345 "Cursor.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_SQLRelay__Cursor_getOutputBindBlob); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_SQLRelay__Cursor_getOutputBindBlob)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, variable");
    {
	const char *	variable = (const char *)SvPV_nolen(ST(1))
;
	sqlrcursor *	THIS;
	const char *	RETVAL;
	dXSTARG;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (sqlrcursor *)SvIV((SV*)SvRV( ST(0) ));
	else{
		warn( "SQLRelay::Cursor::getOutputBindBlob() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 339 "Cursor.xs"
		const char	*value=THIS->getOutputBindBlob(variable);
		uint32_t	length=THIS->getOutputBindLength(variable);
		ST(0)=sv_newmortal();
		if (value) {
			sv_setpvn(ST(0),value,length);
		} else {
			ST(0)=&sv_undef;
		}
#line 1380 "Cursor.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_SQLRelay__Cursor_getOutputBindClob); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_SQLRelay__Cursor_getOutputBindClob)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, variable");
    {
	const char *	variable = (const char *)SvPV_nolen(ST(1))
;
	sqlrcursor *	THIS;
	const char *	RETVAL;
	dXSTARG;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (sqlrcursor *)SvIV((SV*)SvRV( ST(0) ));
	else{
		warn( "SQLRelay::Cursor::getOutputBindClob() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 352 "Cursor.xs"
		const char	*value=THIS->getOutputBindClob(variable);
		uint32_t	length=THIS->getOutputBindLength(variable);
		ST(0)=sv_newmortal();
		if (value) {
			sv_setpvn(ST(0),value,length);
		} else {
			ST(0)=&sv_undef;
		}
#line 1415 "Cursor.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_SQLRelay__Cursor_getOutputBindInteger); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_SQLRelay__Cursor_getOutputBindInteger)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, variable");
    {
	const char *	variable = (const char *)SvPV_nolen(ST(1))
;
	sqlrcursor *	THIS;
	int64_t	RETVAL;
	dXSTARG;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (sqlrcursor *)SvIV((SV*)SvRV( ST(0) ));
	else{
		warn( "SQLRelay::Cursor::getOutputBindInteger() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 365 "Cursor.xs"
		int64_t	value=THIS->getOutputBindInteger(variable);
		ST(0)=sv_newmortal();
		sv_setiv(ST(0),value);
#line 1445 "Cursor.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_SQLRelay__Cursor_getOutputBindDouble); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_SQLRelay__Cursor_getOutputBindDouble)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, variable");
    {
	const char *	variable = (const char *)SvPV_nolen(ST(1))
;
	sqlrcursor *	THIS;
	double	RETVAL;
	dXSTARG;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (sqlrcursor *)SvIV((SV*)SvRV( ST(0) ));
	else{
		warn( "SQLRelay::Cursor::getOutputBindDouble() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 373 "Cursor.xs"
		double	value=THIS->getOutputBindDouble(variable);
		ST(0)=sv_newmortal();
		sv_setnv(ST(0),value);
#line 1475 "Cursor.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_SQLRelay__Cursor_getOutputBindLength); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_SQLRelay__Cursor_getOutputBindLength)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, variable");
    {
	const char *	variable = (const char *)SvPV_nolen(ST(1))
;
	sqlrcursor *	THIS;
	uint32_t	RETVAL;
	dXSTARG;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (sqlrcursor *)SvIV((SV*)SvRV( ST(0) ));
	else{
		warn( "SQLRelay::Cursor::getOutputBindLength() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	RETVAL = THIS->getOutputBindLength(variable);
	XSprePUSH; PUSHu((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_SQLRelay__Cursor_getOutputBindCursor); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_SQLRelay__Cursor_getOutputBindCursor)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, variable");
    {
	const char *	variable = (const char *)SvPV_nolen(ST(1))
;
	sqlrcursor *	THIS;
	sqlrcursor *	RETVAL;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (sqlrcursor *)SvIV((SV*)SvRV( ST(0) ));
	else{
		warn( "SQLRelay::Cursor::getOutputBindCursor() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 385 "Cursor.xs"
#ifndef PERLREALLYOLD
		char *	CLASS = "SQLRelay::Cursor";
#endif
		RETVAL=THIS->getOutputBindCursor(variable,true);
#line 1533 "Cursor.c"
	ST(0) = sv_newmortal();
	sv_setref_pv( ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_SQLRelay__Cursor_openCachedResultSet); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_SQLRelay__Cursor_openCachedResultSet)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, filename");
    {
	const char *	filename = (const char *)SvPV_nolen(ST(1))
;
	sqlrcursor *	THIS;
	bool	RETVAL;
	dXSTARG;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (sqlrcursor *)SvIV((SV*)SvRV( ST(0) ));
	else{
		warn( "SQLRelay::Cursor::openCachedResultSet() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	RETVAL = THIS->openCachedResultSet(filename);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_SQLRelay__Cursor_colCount); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_SQLRelay__Cursor_colCount)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	sqlrcursor *	THIS;
	uint32_t	RETVAL;
	dXSTARG;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (sqlrcursor *)SvIV((SV*)SvRV( ST(0) ));
	else{
		warn( "SQLRelay::Cursor::colCount() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	RETVAL = THIS->colCount();
	XSprePUSH; PUSHu((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_SQLRelay__Cursor_rowCount); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_SQLRelay__Cursor_rowCount)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	sqlrcursor *	THIS;
	uint64_t	RETVAL;
	dXSTARG;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (sqlrcursor *)SvIV((SV*)SvRV( ST(0) ));
	else{
		warn( "SQLRelay::Cursor::rowCount() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	RETVAL = THIS->rowCount();
	XSprePUSH; PUSHu((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_SQLRelay__Cursor_totalRows); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_SQLRelay__Cursor_totalRows)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	sqlrcursor *	THIS;
	uint64_t	RETVAL;
	dXSTARG;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (sqlrcursor *)SvIV((SV*)SvRV( ST(0) ));
	else{
		warn( "SQLRelay::Cursor::totalRows() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	RETVAL = THIS->totalRows();
	XSprePUSH; PUSHu((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_SQLRelay__Cursor_affectedRows); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_SQLRelay__Cursor_affectedRows)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	sqlrcursor *	THIS;
	uint64_t	RETVAL;
	dXSTARG;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (sqlrcursor *)SvIV((SV*)SvRV( ST(0) ));
	else{
		warn( "SQLRelay::Cursor::affectedRows() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	RETVAL = THIS->affectedRows();
	XSprePUSH; PUSHu((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_SQLRelay__Cursor_firstRowIndex); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_SQLRelay__Cursor_firstRowIndex)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	sqlrcursor *	THIS;
	uint64_t	RETVAL;
	dXSTARG;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (sqlrcursor *)SvIV((SV*)SvRV( ST(0) ));
	else{
		warn( "SQLRelay::Cursor::firstRowIndex() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	RETVAL = THIS->firstRowIndex();
	XSprePUSH; PUSHu((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_SQLRelay__Cursor_endOfResultSet); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_SQLRelay__Cursor_endOfResultSet)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	sqlrcursor *	THIS;
	bool	RETVAL;
	dXSTARG;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (sqlrcursor *)SvIV((SV*)SvRV( ST(0) ));
	else{
		warn( "SQLRelay::Cursor::endOfResultSet() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	RETVAL = THIS->endOfResultSet();
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_SQLRelay__Cursor_errorMessage); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_SQLRelay__Cursor_errorMessage)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	sqlrcursor *	THIS;
	const char *	RETVAL;
	dXSTARG;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (sqlrcursor *)SvIV((SV*)SvRV( ST(0) ));
	else{
		warn( "SQLRelay::Cursor::errorMessage() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	RETVAL = THIS->errorMessage();
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_SQLRelay__Cursor_errorNumber); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_SQLRelay__Cursor_errorNumber)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	sqlrcursor *	THIS;
	int64_t	RETVAL;
	dXSTARG;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (sqlrcursor *)SvIV((SV*)SvRV( ST(0) ));
	else{
		warn( "SQLRelay::Cursor::errorNumber() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	RETVAL = THIS->errorNumber();
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_SQLRelay__Cursor_getNullsAsEmptyStrings); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_SQLRelay__Cursor_getNullsAsEmptyStrings)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	sqlrcursor *	THIS;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (sqlrcursor *)SvIV((SV*)SvRV( ST(0) ));
	else{
		warn( "SQLRelay::Cursor::getNullsAsEmptyStrings() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	THIS->getNullsAsEmptyStrings();
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_SQLRelay__Cursor_getNullsAsUndefined); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_SQLRelay__Cursor_getNullsAsUndefined)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	sqlrcursor *	THIS;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (sqlrcursor *)SvIV((SV*)SvRV( ST(0) ));
	else{
		warn( "SQLRelay::Cursor::getNullsAsUndefined() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 426 "Cursor.xs"
		THIS->getNullsAsNulls();
#line 1818 "Cursor.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_SQLRelay__Cursor_validRow); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_SQLRelay__Cursor_validRow)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, row");
    {
	uint64_t	row;
	sqlrcursor *	THIS;
	bool	RETVAL;
	dXSTARG;

	row=(uint64_t)SvUV(ST(1))
;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (sqlrcursor *)SvIV((SV*)SvRV( ST(0) ));
	else{
		warn( "SQLRelay::Cursor::validRow() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 432 "Cursor.xs"
		RETVAL=1;
		if (!THIS->getRow(row)) {
			RETVAL=0;
		}
#line 1851 "Cursor.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_SQLRelay__Cursor_getField); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_SQLRelay__Cursor_getField)
{
    dVAR; dXSARGS;
    if (items < 2)
       croak_xs_usage(cv,  "THIS, row, ...");
    {
	uint64_t	row;
	sqlrcursor *	THIS;
	const char *	RETVAL;
	dXSTARG;

	row=(uint64_t)SvUV(ST(1))
;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (sqlrcursor *)SvIV((SV*)SvRV( ST(0) ));
	else{
		warn( "SQLRelay::Cursor::getField() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 443 "Cursor.xs"
		const char	*field=NULL;
		uint32_t	length=0;
		ST(0)=sv_newmortal();
		if (SvIOK(ST(2)) || SvNOK(ST(2))) {
			field=THIS->getField(row,(uint32_t)SvIV(ST(2)));
			length=THIS->getFieldLength(row,(uint32_t)SvIV(ST(2)));
		} else if (SvPOK(ST(2))) {
			field=THIS->getField(row,SvPV(ST(2),na));
			length=THIS->getFieldLength(row,SvPV(ST(2),na));
		} 
		if (field) {
			sv_setpvn(ST(0),field,length);
		} else {
			ST(0)=&sv_undef;
		}
#line 1896 "Cursor.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_SQLRelay__Cursor_getFieldAsInteger); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_SQLRelay__Cursor_getFieldAsInteger)
{
    dVAR; dXSARGS;
    if (items < 2)
       croak_xs_usage(cv,  "THIS, row, ...");
    {
	uint64_t	row;
	sqlrcursor *	THIS;
	int64_t	RETVAL;
	dXSTARG;

	row=(uint64_t)SvUV(ST(1))
;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (sqlrcursor *)SvIV((SV*)SvRV( ST(0) ));
	else{
		warn( "SQLRelay::Cursor::getFieldAsInteger() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 463 "Cursor.xs"
		int64_t	field=0;
		ST(0)=sv_newmortal();
		if (SvIOK(ST(2)) || SvNOK(ST(2))) {
			field=THIS->getFieldAsInteger(row,
						(uint32_t)SvIV(ST(2)));
		} else if (SvPOK(ST(2))) {
			field=THIS->getFieldAsInteger(row,SvPV(ST(2),na));
		} 
		sv_setiv(ST(0),field);
#line 1934 "Cursor.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_SQLRelay__Cursor_getFieldAsDouble); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_SQLRelay__Cursor_getFieldAsDouble)
{
    dVAR; dXSARGS;
    if (items < 2)
       croak_xs_usage(cv,  "THIS, row, ...");
    {
	uint64_t	row;
	sqlrcursor *	THIS;
	double	RETVAL;
	dXSTARG;

	row=(uint64_t)SvUV(ST(1))
;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (sqlrcursor *)SvIV((SV*)SvRV( ST(0) ));
	else{
		warn( "SQLRelay::Cursor::getFieldAsDouble() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 477 "Cursor.xs"
		double	field=0.0;
		ST(0)=sv_newmortal();
		if (SvIOK(ST(2)) || SvNOK(ST(2))) {
			field=THIS->getFieldAsDouble(row,(uint32_t)SvIV(ST(2)));
		} else if (SvPOK(ST(2))) {
			field=THIS->getFieldAsDouble(row,SvPV(ST(2),na));
		} 
		sv_setnv(ST(0),field);
#line 1971 "Cursor.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_SQLRelay__Cursor_getFieldLength); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_SQLRelay__Cursor_getFieldLength)
{
    dVAR; dXSARGS;
    if (items < 2)
       croak_xs_usage(cv,  "THIS, row, ...");
    {
	uint64_t	row;
	sqlrcursor *	THIS;
	uint32_t	RETVAL;
	dXSTARG;

	row=(uint64_t)SvUV(ST(1))
;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (sqlrcursor *)SvIV((SV*)SvRV( ST(0) ));
	else{
		warn( "SQLRelay::Cursor::getFieldLength() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 490 "Cursor.xs"
		RETVAL=0;
		if (SvIOK(ST(2)) || SvNOK(ST(2))) {
			RETVAL=THIS->getFieldLength(row,(uint32_t)SvIV(ST(2)));
		} else if (SvPOK(ST(2))) {
			RETVAL=THIS->getFieldLength(row,SvPV(ST(2),na));
		}
#line 2006 "Cursor.c"
	XSprePUSH; PUSHu((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_SQLRelay__Cursor_getColumnNames); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_SQLRelay__Cursor_getColumnNames)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	sqlrcursor *	THIS;
	const char * const *	RETVAL;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (sqlrcursor *)SvIV((SV*)SvRV( ST(0) ));
	else{
		warn( "SQLRelay::Cursor::getColumnNames() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 502 "Cursor.xs"
		uint32_t	index=0;
		const char * const *namesptr=THIS->getColumnNames();
		EXTEND(SP,THIS->colCount());
		if (namesptr) {
			for (index=0; index<THIS->colCount(); index++) {
				// On some platforms newSVpv takes a char *
				// argument rather than a const char *
				// argument.
				PUSHs(sv_2mortal(
					newSVpv((char *)namesptr[index],0)));
			}
		}
#line 2045 "Cursor.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_SQLRelay__Cursor_getColumnName); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_SQLRelay__Cursor_getColumnName)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, col");
    {
	uint32_t	col;
	sqlrcursor *	THIS;
	const char *	RETVAL;
	dXSTARG;

	col=(uint32_t)SvUV(ST(1))
;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (sqlrcursor *)SvIV((SV*)SvRV( ST(0) ));
	else{
		warn( "SQLRelay::Cursor::getColumnName() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	RETVAL = THIS->getColumnName(col);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_SQLRelay__Cursor_getColumnType); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_SQLRelay__Cursor_getColumnType)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "THIS, ...");
    {
	sqlrcursor *	THIS;
	const char *	RETVAL;
	dXSTARG;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (sqlrcursor *)SvIV((SV*)SvRV( ST(0) ));
	else{
		warn( "SQLRelay::Cursor::getColumnType() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 522 "Cursor.xs"
		RETVAL=NULL;
		if (SvIOK(ST(1)) || SvNOK(ST(1))) {
			RETVAL=THIS->getColumnType((uint32_t)SvIV(ST(1)));
		} else if (SvPOK(ST(1))) {
			RETVAL=THIS->getColumnType(SvPV(ST(1),na));
		}
#line 2107 "Cursor.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_SQLRelay__Cursor_getColumnLength); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_SQLRelay__Cursor_getColumnLength)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "THIS, ...");
    {
	sqlrcursor *	THIS;
	uint32_t	RETVAL;
	dXSTARG;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (sqlrcursor *)SvIV((SV*)SvRV( ST(0) ));
	else{
		warn( "SQLRelay::Cursor::getColumnLength() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 534 "Cursor.xs"
		RETVAL=0;
		if (SvIOK(ST(1)) || SvNOK(ST(1))) {
			RETVAL=THIS->getColumnLength((uint32_t)SvIV(ST(1)));
		} else if (SvPOK(ST(1))) {
			RETVAL=THIS->getColumnLength(SvPV(ST(1),na));
		}
#line 2139 "Cursor.c"
	XSprePUSH; PUSHu((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_SQLRelay__Cursor_getColumnPrecision); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_SQLRelay__Cursor_getColumnPrecision)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "THIS, ...");
    {
	sqlrcursor *	THIS;
	uint32_t	RETVAL;
	dXSTARG;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (sqlrcursor *)SvIV((SV*)SvRV( ST(0) ));
	else{
		warn( "SQLRelay::Cursor::getColumnPrecision() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 546 "Cursor.xs"
		RETVAL=0;
		if (SvIOK(ST(1)) || SvNOK(ST(1))) {
			RETVAL=THIS->getColumnPrecision((uint32_t)SvIV(ST(1)));
		} else if (SvPOK(ST(1))) {
			RETVAL=THIS->getColumnPrecision(SvPV(ST(1),na));
		}
#line 2171 "Cursor.c"
	XSprePUSH; PUSHu((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_SQLRelay__Cursor_getColumnScale); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_SQLRelay__Cursor_getColumnScale)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "THIS, ...");
    {
	sqlrcursor *	THIS;
	uint32_t	RETVAL;
	dXSTARG;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (sqlrcursor *)SvIV((SV*)SvRV( ST(0) ));
	else{
		warn( "SQLRelay::Cursor::getColumnScale() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 558 "Cursor.xs"
		RETVAL=0;
		if (SvIOK(ST(1)) || SvNOK(ST(1))) {
			RETVAL=THIS->getColumnScale((uint32_t)SvIV(ST(1)));
		} else if (SvPOK(ST(1))) {
			RETVAL=THIS->getColumnScale(SvPV(ST(1),na));
		}
#line 2203 "Cursor.c"
	XSprePUSH; PUSHu((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_SQLRelay__Cursor_getColumnIsNullable); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_SQLRelay__Cursor_getColumnIsNullable)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "THIS, ...");
    {
	sqlrcursor *	THIS;
	bool	RETVAL;
	dXSTARG;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (sqlrcursor *)SvIV((SV*)SvRV( ST(0) ));
	else{
		warn( "SQLRelay::Cursor::getColumnIsNullable() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 570 "Cursor.xs"
		RETVAL=0;
		if (SvIOK(ST(1)) || SvNOK(ST(1))) {
			RETVAL=THIS->getColumnIsNullable((uint32_t)SvIV(ST(1)));
		} else if (SvPOK(ST(1))) {
			RETVAL=THIS->getColumnIsNullable(SvPV(ST(1),na));
		}
#line 2235 "Cursor.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_SQLRelay__Cursor_getColumnIsPrimaryKey); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_SQLRelay__Cursor_getColumnIsPrimaryKey)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "THIS, ...");
    {
	sqlrcursor *	THIS;
	bool	RETVAL;
	dXSTARG;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (sqlrcursor *)SvIV((SV*)SvRV( ST(0) ));
	else{
		warn( "SQLRelay::Cursor::getColumnIsPrimaryKey() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 582 "Cursor.xs"
		RETVAL=0;
		if (SvIOK(ST(1)) || SvNOK(ST(1))) {
			RETVAL=THIS->getColumnIsPrimaryKey((uint32_t)SvIV(ST(1)));
		} else if (SvPOK(ST(1))) {
			RETVAL=THIS->getColumnIsPrimaryKey(SvPV(ST(1),na));
		}
#line 2267 "Cursor.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_SQLRelay__Cursor_getColumnIsUnique); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_SQLRelay__Cursor_getColumnIsUnique)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "THIS, ...");
    {
	sqlrcursor *	THIS;
	bool	RETVAL;
	dXSTARG;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (sqlrcursor *)SvIV((SV*)SvRV( ST(0) ));
	else{
		warn( "SQLRelay::Cursor::getColumnIsUnique() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 594 "Cursor.xs"
		RETVAL=0;
		if (SvIOK(ST(1)) || SvNOK(ST(1))) {
			RETVAL=THIS->getColumnIsUnique((uint32_t)SvIV(ST(1)));
		} else if (SvPOK(ST(1))) {
			RETVAL=THIS->getColumnIsUnique(SvPV(ST(1),na));
		}
#line 2299 "Cursor.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_SQLRelay__Cursor_getColumnIsPartOfKey); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_SQLRelay__Cursor_getColumnIsPartOfKey)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "THIS, ...");
    {
	sqlrcursor *	THIS;
	bool	RETVAL;
	dXSTARG;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (sqlrcursor *)SvIV((SV*)SvRV( ST(0) ));
	else{
		warn( "SQLRelay::Cursor::getColumnIsPartOfKey() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 606 "Cursor.xs"
		RETVAL=0;
		if (SvIOK(ST(1)) || SvNOK(ST(1))) {
			RETVAL=THIS->getColumnIsPartOfKey((uint32_t)SvIV(ST(1)));
		} else if (SvPOK(ST(1))) {
			RETVAL=THIS->getColumnIsPartOfKey(SvPV(ST(1),na));
		}
#line 2331 "Cursor.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_SQLRelay__Cursor_getColumnIsUnsigned); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_SQLRelay__Cursor_getColumnIsUnsigned)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "THIS, ...");
    {
	sqlrcursor *	THIS;
	bool	RETVAL;
	dXSTARG;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (sqlrcursor *)SvIV((SV*)SvRV( ST(0) ));
	else{
		warn( "SQLRelay::Cursor::getColumnIsUnsigned() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 618 "Cursor.xs"
		RETVAL=0;
		if (SvIOK(ST(1)) || SvNOK(ST(1))) {
			RETVAL=THIS->getColumnIsUnsigned((uint32_t)SvIV(ST(1)));
		} else if (SvPOK(ST(1))) {
			RETVAL=THIS->getColumnIsUnsigned(SvPV(ST(1),na));
		}
#line 2363 "Cursor.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_SQLRelay__Cursor_getColumnIsZeroFilled); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_SQLRelay__Cursor_getColumnIsZeroFilled)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "THIS, ...");
    {
	sqlrcursor *	THIS;
	bool	RETVAL;
	dXSTARG;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (sqlrcursor *)SvIV((SV*)SvRV( ST(0) ));
	else{
		warn( "SQLRelay::Cursor::getColumnIsZeroFilled() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 630 "Cursor.xs"
		RETVAL=0;
		if (SvIOK(ST(1)) || SvNOK(ST(1))) {
			RETVAL=THIS->getColumnIsZeroFilled((uint32_t)SvIV(ST(1)));
		} else if (SvPOK(ST(1))) {
			RETVAL=THIS->getColumnIsZeroFilled(SvPV(ST(1),na));
		}
#line 2395 "Cursor.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_SQLRelay__Cursor_getColumnIsBinary); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_SQLRelay__Cursor_getColumnIsBinary)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "THIS, ...");
    {
	sqlrcursor *	THIS;
	bool	RETVAL;
	dXSTARG;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (sqlrcursor *)SvIV((SV*)SvRV( ST(0) ));
	else{
		warn( "SQLRelay::Cursor::getColumnIsBinary() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 642 "Cursor.xs"
		RETVAL=0;
		if (SvIOK(ST(1)) || SvNOK(ST(1))) {
			RETVAL=THIS->getColumnIsBinary((uint32_t)SvIV(ST(1)));
		} else if (SvPOK(ST(1))) {
			RETVAL=THIS->getColumnIsBinary(SvPV(ST(1),na));
		}
#line 2427 "Cursor.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_SQLRelay__Cursor_getColumnIsAutoIncrement); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_SQLRelay__Cursor_getColumnIsAutoIncrement)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "THIS, ...");
    {
	sqlrcursor *	THIS;
	bool	RETVAL;
	dXSTARG;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (sqlrcursor *)SvIV((SV*)SvRV( ST(0) ));
	else{
		warn( "SQLRelay::Cursor::getColumnIsAutoIncrement() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 654 "Cursor.xs"
		RETVAL=0;
		if (SvIOK(ST(1)) || SvNOK(ST(1))) {
			RETVAL=THIS->getColumnIsAutoIncrement((uint32_t)SvIV(ST(1)));
		} else if (SvPOK(ST(1))) {
			RETVAL=THIS->getColumnIsAutoIncrement(SvPV(ST(1),na));
		}
#line 2459 "Cursor.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_SQLRelay__Cursor_getLongest); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_SQLRelay__Cursor_getLongest)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "THIS, ...");
    {
	sqlrcursor *	THIS;
	uint32_t	RETVAL;
	dXSTARG;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (sqlrcursor *)SvIV((SV*)SvRV( ST(0) ));
	else{
		warn( "SQLRelay::Cursor::getLongest() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;
#line 665 "Cursor.xs"
		RETVAL=0;
		if (SvIOK(ST(1)) || SvNOK(ST(1))) {
			RETVAL=THIS->getLongest((uint32_t)SvIV(ST(1)));
		} else if (SvPOK(ST(1))) {
			RETVAL=THIS->getLongest(SvPV(ST(1),na));
		}
#line 2490 "Cursor.c"
	XSprePUSH; PUSHu((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_SQLRelay__Cursor_getResultSetId); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_SQLRelay__Cursor_getResultSetId)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	sqlrcursor *	THIS;
	uint16_t	RETVAL;
	dXSTARG;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (sqlrcursor *)SvIV((SV*)SvRV( ST(0) ));
	else{
		warn( "SQLRelay::Cursor::getResultSetId() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	RETVAL = THIS->getResultSetId();
	XSprePUSH; PUSHu((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_SQLRelay__Cursor_suspendResultSet); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_SQLRelay__Cursor_suspendResultSet)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	sqlrcursor *	THIS;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (sqlrcursor *)SvIV((SV*)SvRV( ST(0) ));
	else{
		warn( "SQLRelay::Cursor::suspendResultSet() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	THIS->suspendResultSet();
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_SQLRelay__Cursor_resumeResultSet); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_SQLRelay__Cursor_resumeResultSet)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, id");
    {
	uint16_t	id;
	sqlrcursor *	THIS;
	bool	RETVAL;
	dXSTARG;

	id=(uint16_t)SvUV(ST(1))
;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (sqlrcursor *)SvIV((SV*)SvRV( ST(0) ));
	else{
		warn( "SQLRelay::Cursor::resumeResultSet() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	RETVAL = THIS->resumeResultSet(id);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_SQLRelay__Cursor_resumeCachedResultSet); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_SQLRelay__Cursor_resumeCachedResultSet)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, id, filename");
    {
	uint16_t	id;
	const char *	filename = (const char *)SvPV_nolen(ST(2))
;
	sqlrcursor *	THIS;
	bool	RETVAL;
	dXSTARG;

	id=(uint16_t)SvUV(ST(1))
;

	if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
		THIS = (sqlrcursor *)SvIV((SV*)SvRV( ST(0) ));
	else{
		warn( "SQLRelay::Cursor::resumeCachedResultSet() -- THIS is not a blessed SV reference" );
		XSRETURN_UNDEF;
	}
;

	RETVAL = THIS->resumeCachedResultSet(id, filename);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#ifdef __cplusplus
extern "C"
#endif
XS_EXTERNAL(boot_SQLRelay__Cursor); /* prototype to pass -Wmissing-prototypes */
XS_EXTERNAL(boot_SQLRelay__Cursor)
{
    dVAR; dXSARGS;
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
#ifdef XS_APIVERSION_BOOTCHECK
    XS_APIVERSION_BOOTCHECK;
#endif
    XS_VERSION_BOOTCHECK;

        newXS("SQLRelay::Cursor::new", XS_SQLRelay__Cursor_new, file);
        newXS("SQLRelay::Cursor::DESTROY", XS_SQLRelay__Cursor_DESTROY, file);
        newXS("SQLRelay::Cursor::setResultSetBufferSize", XS_SQLRelay__Cursor_setResultSetBufferSize, file);
        newXS("SQLRelay::Cursor::getResultSetBufferSize", XS_SQLRelay__Cursor_getResultSetBufferSize, file);
        newXS("SQLRelay::Cursor::dontGetColumnInfo", XS_SQLRelay__Cursor_dontGetColumnInfo, file);
        newXS("SQLRelay::Cursor::getColumnInfo", XS_SQLRelay__Cursor_getColumnInfo, file);
        newXS("SQLRelay::Cursor::mixedCaseColumnNames", XS_SQLRelay__Cursor_mixedCaseColumnNames, file);
        newXS("SQLRelay::Cursor::upperCaseColumnNames", XS_SQLRelay__Cursor_upperCaseColumnNames, file);
        newXS("SQLRelay::Cursor::lowerCaseColumnNames", XS_SQLRelay__Cursor_lowerCaseColumnNames, file);
        newXS("SQLRelay::Cursor::cacheToFile", XS_SQLRelay__Cursor_cacheToFile, file);
        newXS("SQLRelay::Cursor::setCacheTtl", XS_SQLRelay__Cursor_setCacheTtl, file);
        newXS("SQLRelay::Cursor::getCacheFileName", XS_SQLRelay__Cursor_getCacheFileName, file);
        newXS("SQLRelay::Cursor::cacheOff", XS_SQLRelay__Cursor_cacheOff, file);
        newXS("SQLRelay::Cursor::getDatabaseList", XS_SQLRelay__Cursor_getDatabaseList, file);
        newXS("SQLRelay::Cursor::getTableList", XS_SQLRelay__Cursor_getTableList, file);
        newXS("SQLRelay::Cursor::getColumnList", XS_SQLRelay__Cursor_getColumnList, file);
        newXS("SQLRelay::Cursor::sendQuery", XS_SQLRelay__Cursor_sendQuery, file);
        newXS("SQLRelay::Cursor::sendQueryWithLength", XS_SQLRelay__Cursor_sendQueryWithLength, file);
        newXS("SQLRelay::Cursor::sendFileQuery", XS_SQLRelay__Cursor_sendFileQuery, file);
        newXS("SQLRelay::Cursor::prepareQuery", XS_SQLRelay__Cursor_prepareQuery, file);
        newXS("SQLRelay::Cursor::prepareQueryWithLength", XS_SQLRelay__Cursor_prepareQueryWithLength, file);
        newXS("SQLRelay::Cursor::prepareFileQuery", XS_SQLRelay__Cursor_prepareFileQuery, file);
        newXS("SQLRelay::Cursor::substitution", XS_SQLRelay__Cursor_substitution, file);
        newXS("SQLRelay::Cursor::clearBinds", XS_SQLRelay__Cursor_clearBinds, file);
        newXS("SQLRelay::Cursor::countBindVariables", XS_SQLRelay__Cursor_countBindVariables, file);
        newXS("SQLRelay::Cursor::inputBind", XS_SQLRelay__Cursor_inputBind, file);
        newXS("SQLRelay::Cursor::inputBindBlob", XS_SQLRelay__Cursor_inputBindBlob, file);
        newXS("SQLRelay::Cursor::inputBindClob", XS_SQLRelay__Cursor_inputBindClob, file);
        newXS("SQLRelay::Cursor::validateBinds", XS_SQLRelay__Cursor_validateBinds, file);
        newXS("SQLRelay::Cursor::validBind", XS_SQLRelay__Cursor_validBind, file);
        newXS("SQLRelay::Cursor::executeQuery", XS_SQLRelay__Cursor_executeQuery, file);
        newXS("SQLRelay::Cursor::fetchFromBindCursor", XS_SQLRelay__Cursor_fetchFromBindCursor, file);
        newXS("SQLRelay::Cursor::defineOutputBindString", XS_SQLRelay__Cursor_defineOutputBindString, file);
        newXS("SQLRelay::Cursor::defineOutputBindInteger", XS_SQLRelay__Cursor_defineOutputBindInteger, file);
        newXS("SQLRelay::Cursor::defineOutputBindDouble", XS_SQLRelay__Cursor_defineOutputBindDouble, file);
        newXS("SQLRelay::Cursor::defineOutputBindBlob", XS_SQLRelay__Cursor_defineOutputBindBlob, file);
        newXS("SQLRelay::Cursor::defineOutputBindClob", XS_SQLRelay__Cursor_defineOutputBindClob, file);
        newXS("SQLRelay::Cursor::defineOutputBindCursor", XS_SQLRelay__Cursor_defineOutputBindCursor, file);
        newXS("SQLRelay::Cursor::getOutputBindString", XS_SQLRelay__Cursor_getOutputBindString, file);
        newXS("SQLRelay::Cursor::getOutputBindBlob", XS_SQLRelay__Cursor_getOutputBindBlob, file);
        newXS("SQLRelay::Cursor::getOutputBindClob", XS_SQLRelay__Cursor_getOutputBindClob, file);
        newXS("SQLRelay::Cursor::getOutputBindInteger", XS_SQLRelay__Cursor_getOutputBindInteger, file);
        newXS("SQLRelay::Cursor::getOutputBindDouble", XS_SQLRelay__Cursor_getOutputBindDouble, file);
        newXS("SQLRelay::Cursor::getOutputBindLength", XS_SQLRelay__Cursor_getOutputBindLength, file);
        newXS("SQLRelay::Cursor::getOutputBindCursor", XS_SQLRelay__Cursor_getOutputBindCursor, file);
        newXS("SQLRelay::Cursor::openCachedResultSet", XS_SQLRelay__Cursor_openCachedResultSet, file);
        newXS("SQLRelay::Cursor::colCount", XS_SQLRelay__Cursor_colCount, file);
        newXS("SQLRelay::Cursor::rowCount", XS_SQLRelay__Cursor_rowCount, file);
        newXS("SQLRelay::Cursor::totalRows", XS_SQLRelay__Cursor_totalRows, file);
        newXS("SQLRelay::Cursor::affectedRows", XS_SQLRelay__Cursor_affectedRows, file);
        newXS("SQLRelay::Cursor::firstRowIndex", XS_SQLRelay__Cursor_firstRowIndex, file);
        newXS("SQLRelay::Cursor::endOfResultSet", XS_SQLRelay__Cursor_endOfResultSet, file);
        newXS("SQLRelay::Cursor::errorMessage", XS_SQLRelay__Cursor_errorMessage, file);
        newXS("SQLRelay::Cursor::errorNumber", XS_SQLRelay__Cursor_errorNumber, file);
        newXS("SQLRelay::Cursor::getNullsAsEmptyStrings", XS_SQLRelay__Cursor_getNullsAsEmptyStrings, file);
        newXS("SQLRelay::Cursor::getNullsAsUndefined", XS_SQLRelay__Cursor_getNullsAsUndefined, file);
        newXS("SQLRelay::Cursor::validRow", XS_SQLRelay__Cursor_validRow, file);
        newXS("SQLRelay::Cursor::getField", XS_SQLRelay__Cursor_getField, file);
        newXS("SQLRelay::Cursor::getFieldAsInteger", XS_SQLRelay__Cursor_getFieldAsInteger, file);
        newXS("SQLRelay::Cursor::getFieldAsDouble", XS_SQLRelay__Cursor_getFieldAsDouble, file);
        newXS("SQLRelay::Cursor::getFieldLength", XS_SQLRelay__Cursor_getFieldLength, file);
        newXS("SQLRelay::Cursor::getColumnNames", XS_SQLRelay__Cursor_getColumnNames, file);
        newXS("SQLRelay::Cursor::getColumnName", XS_SQLRelay__Cursor_getColumnName, file);
        newXS("SQLRelay::Cursor::getColumnType", XS_SQLRelay__Cursor_getColumnType, file);
        newXS("SQLRelay::Cursor::getColumnLength", XS_SQLRelay__Cursor_getColumnLength, file);
        newXS("SQLRelay::Cursor::getColumnPrecision", XS_SQLRelay__Cursor_getColumnPrecision, file);
        newXS("SQLRelay::Cursor::getColumnScale", XS_SQLRelay__Cursor_getColumnScale, file);
        newXS("SQLRelay::Cursor::getColumnIsNullable", XS_SQLRelay__Cursor_getColumnIsNullable, file);
        newXS("SQLRelay::Cursor::getColumnIsPrimaryKey", XS_SQLRelay__Cursor_getColumnIsPrimaryKey, file);
        newXS("SQLRelay::Cursor::getColumnIsUnique", XS_SQLRelay__Cursor_getColumnIsUnique, file);
        newXS("SQLRelay::Cursor::getColumnIsPartOfKey", XS_SQLRelay__Cursor_getColumnIsPartOfKey, file);
        newXS("SQLRelay::Cursor::getColumnIsUnsigned", XS_SQLRelay__Cursor_getColumnIsUnsigned, file);
        newXS("SQLRelay::Cursor::getColumnIsZeroFilled", XS_SQLRelay__Cursor_getColumnIsZeroFilled, file);
        newXS("SQLRelay::Cursor::getColumnIsBinary", XS_SQLRelay__Cursor_getColumnIsBinary, file);
        newXS("SQLRelay::Cursor::getColumnIsAutoIncrement", XS_SQLRelay__Cursor_getColumnIsAutoIncrement, file);
        newXS("SQLRelay::Cursor::getLongest", XS_SQLRelay__Cursor_getLongest, file);
        newXS("SQLRelay::Cursor::getResultSetId", XS_SQLRelay__Cursor_getResultSetId, file);
        newXS("SQLRelay::Cursor::suspendResultSet", XS_SQLRelay__Cursor_suspendResultSet, file);
        newXS("SQLRelay::Cursor::resumeResultSet", XS_SQLRelay__Cursor_resumeResultSet, file);
        newXS("SQLRelay::Cursor::resumeCachedResultSet", XS_SQLRelay__Cursor_resumeCachedResultSet, file);
#if (PERL_REVISION == 5 && PERL_VERSION >= 9)
  if (PL_unitcheckav)
       call_list(PL_scopestack_ix, PL_unitcheckav);
#endif
    XSRETURN_YES;
}

